h1. Introduction.

p. 
Suave is a simple web development F# library providing a lightweight web server and a set of combinators to manipulate route flow and task composition. Suave is inspired in the simplicity of Happstack and born out of the necessity of embedding web server capabilities in my own applications. 
Still in its early stages Suave supports HTTPS, multiple TCP/IP bindings, Basic Access Authentication, Keep-Alive. Suave also takes advantage of F# asynchronous workflows to perform non-blocking IO.

h2. Hello World!

p. 
The simplest Suave application is a simple server that greets all visitors with the string Hello World!

pre. 
web_server [|HTTP, "127.0.0.1",80|] (ok "Hello World")
|> Async.RunSynchronously
|> ignore; 

p. 
web_server takes an array of bindings: [|HTTP, "127.0.0.1",80|] and a webpart: (ok "Hello World") and returns an asynchronous computation. Webparts are functions with the following type: HttpRequest -> Option<Async<unit>>. For every request web_server will evaluate the webpart, if the evaluation succeeds it will execute the resulting asynchronous computation. ok is a combinator that always succeed and writes its argument to the underlying response stream.

h1. Composing bigger programs.

p. 
Logic is expressed with the help of different combinators built around the option<HttpRequest> type. We build webparts out of functions of type (HttpRequest -> HttpRequest option) and the operator >>= in the following way.

pre. 
let simple_app _ = url "/hello" >>= ok "Hello World" ;

p. 
To select between different routes or options we use the function choose; for example:

pre. 
let complex_app _ = 
    choose [
        Console.OpenStandardOutput() |> log >>= never; 
        url "/hello" >>= never >>= ok "Never executes";
        url "/hello" >>= ok "Hello World"  ;
    ]

p. 
The function choose accepts a list of webparts and execute each webpart in the list until one returns success. Since choose itself returns a webpart we can nest them for more complex logic.

pre. 
let nested_logic _= 
    choose [
        meth0d "GET" >>= choose 
            [ url "/hello" >>= ok "Hello GET" ; url "/goodbye" >>= ok "Good bye GET" ];
        meth0d "POST" >>= choose 
            [ url "/hello" >>= ok "Hello POST" ; url "/goodbye" >>= ok "Good bye POST" ];
    ]

p. 
To gain access to the underlying HttpRequest and read query and http form data we can use the warbler* combinator.

pre. 
let http_form _ = 
    choose [
         meth0d "GET"  >>= url "/query" >>= warbler( fun x -> ok ("Hello " + (x.Query) ? name));
         meth0d "POST" >>= url "/query" >>= warbler( fun x -> ok ("Hello " + (x.Form)  ? name));
         notfound "Found no handlers"
    ]

p. 
Here is how http authentication would work:

pre. 
let requires_authentication _ = 
    choose [
         meth0d "GET" >>= url "/public" >>= ok ("Hello anonymous");
         //access to handlers bellow this one will require authentication
         authenticate_basic ( fun x -> x.Username.Equals("foo") && x.Password.Equals("bar"));
         meth0d "GET" >>= url "/protected" >>= warbler( fun x -> ok ("Hello " + x.Username));
    ]

p. 
*warbler gets its name from the famous book "To Mock a Mockingbird" by Raymond Smullyan.

h1. Multiple bindings and SSL support

p. 
Suave supports binding the application to multiple TCP/IP addresses and ports combinations. It also supports HTTPS.

pre. 
let sslCert = new X509Certificate("suave.pfx","easy");
choose [
    Console.OpenStandardOutput() |> log >>= never ; // log to standard output
    url "/hello" >>= ok "Hello World" ; 
    notfound "Found no handlers"     
    ] 
    |> web_server [|HTTP,"127.0.0.1",80; HTTPS(sslCert),"192.168.13.138",443|]
    |> Async.RunSynchronously
    |> ignore 

